////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// - Plug-In Shader - by Joshua
//   Base Shader: Simple Soft Shader by BeanManP
// 
//
////////////////////////////////////////////////////////////////////////////////////////////////
//Samplers

// Object Texture
#if APPLY_ANIMATED_TEXTURE == 0
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#if APPLY_ANIMATED_TEXTURE == 1
texture2D ObjectTexture : ANIMATEDTEXTURE <
    string ResourceName = Animated_Texture
>;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#if APPLY_SPA == 1
// Sphere Map Texture
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
    texture = <ObjectSphereMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#if APPLY_NORMALMAP == 1
//Normal Map
#if APPLY_ANIMATED_NORMALMAP == 0
texture2D NormalMap <
#endif
#if APPLY_ANIMATED_NORMALMAP == 1
texture2D NormalMap : ANIMATEDTEXTURE <
#endif
    string ResourceName = NormalMap_Texture
>;
sampler NormalMapSampler = sampler_state {
    texture = <NormalMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#if APPLY_SPECULARMAP == 1
//Specular Map
texture2D SpecularMap <
    string ResourceName = SpecularMap_Texture
>;
sampler SpecularMapSampler = sampler_state {
    texture = <SpecularMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#if APPLY_CUBEMAP == 1
//Cube Map
textureCUBE CubeMap <
    string ResourceName = CubeMap_Texture
>;
sampler CubeMapSampler = sampler_state {
    texture = <CubeMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

//Height Map Texture
#if APPLY_HEIGHTMAP == 1

  texture2D HeightMap
< string ResourceName = HeightMap_Texture; >;
	sampler HeightMap_Sampler = sampler_state {
    texture   = <HeightMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

//Transparency Mask
#if APPLY_TRANSPARENCY == 1
texture2D TransparencyMask <
    string ResourceName = Transparency_Texture
    >;
sampler Transparency_Sampler = sampler_state {
    texture   = <TransparencyMask>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif
//Alpha Mask
#if APPLY_ALPHA_MASK == 1
texture2D AlphaMask <
    string ResourceName = Alpha_Mask_Texture
    >;
sampler Alpha_Mask_Sampler = sampler_state {
    texture   = <AlphaMask>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

//SubSurfaceToon
#if APPLY_SUBSURFACETOON == 1
#if APPLY_SUBSURFACETOON_MAP == 1
texture2D SubSurfaceToonMap <
    string ResourceName = SubSurfaceToon_Map_Texture
    >;
sampler SubSurfaceToon_Map_Sampler = sampler_state {
    texture   = <SubSurfaceToonMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif
#endif

#define SSS_Control  "SSS.x"
bool SSS_Valid  : CONTROLOBJECT < string name = SSS_Control; >;

//SSS Map
shared texture2D SSSTex : RENDERCOLORTARGET;
sampler2D SSS_Samp = sampler_state {
    texture = <SSSTex>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};

#define Aniso_Control  "ANISO.x"
bool Aniso_Valid  : CONTROLOBJECT < string name = Aniso_Control; >;

//Aniso Map
shared texture2D AnisoTex : RENDERCOLORTARGET;
sampler2D Aniso_Samp = sampler_state {
    texture = <AnisoTex>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};

//Refraction Texture
#if APPLY_REFRACTION == 1
#if APPLY_REFRACTION_REFLECTION == 0
textureCUBE Refraction <
    string ResourceName = Refraction_Texture
    >;
sampler Refraction_Sampler = sampler_state {
    texture = <Refraction>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif
#endif

//Reflection Reflection

#if APPLY_REFRACTION == 1
#if APPLY_REFRACTION_REFLECTION == 1
texture EnvMapF: OFFSCREENRENDERTARGET <
    int Width = WIDTH;
    int Height = HEIGHT;
    float4 ClearColor = { 0, 0, 0, 1 };
    float ClearDepth = 1.0;
	#if ENABLE_REFRACTION_ANTI_ALIAS == 0
    bool AntiAlias = false;
	#endif
	#if ENABLE_REFRACTION_ANTI_ALIAS == 1
    bool AntiAlias = true;
	#endif
    int Miplevels=0;
>;

sampler sampEnvMapF = sampler_state {
    texture = <EnvMapF>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

texture EnvMapB: OFFSCREENRENDERTARGET <
    int Width = WIDTH;
    int Height = HEIGHT;
    float4 ClearColor = { 0, 0, 0, 1 };
    float ClearDepth = 1.0;
	#if ENABLE_REFRACTION_ANTI_ALIAS == 0
    bool AntiAlias = false;
	#endif
	#if ENABLE_REFRACTION_ANTI_ALIAS == 1
    bool AntiAlias = true;
	#endif
    int Miplevels=0;
>;

sampler sampEnvMapB = sampler_state {
    texture = <EnvMapB>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

float4 texDP(sampler2D sampFront, sampler2D sampBack, float3 vec) {
    vec = normalize(vec);
    bool front = (vec.z >= 0);
    if ( !front ) vec.xz = -vec.xz;
    
    float2 uv;
    uv = vec.xy / (1+vec.z);
    uv.y = -uv.y;
    uv = uv * 0.5 + 0.5;
    
    float4 ret;
    if ( front ) {
        ret = tex2D(sampFront, uv);
    } else {
        ret = tex2D(sampBack, uv);
    }
    
    return ret;
}
#endif
#endif

//Ambient Occlussion
#if APPLY_AMBIENTOCCLUSSION == 1
texture2D AOMAP <
    string ResourceName = AmbientOcclussion_Texture
    >;
sampler AO_Sampler = sampler_state {
    texture   = <AOMAP>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#define IBLRT_Control  "IBL.x"
bool IBLRT_Valid  : CONTROLOBJECT < string name = IBLRT_Control; >;

//IBL RT
shared texture2D IBLRT : RENDERCOLORTARGET;
sampler2D IBLRT_Samp = sampler_state {
    texture = <IBLRT>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};

//Specular RT
shared texture2D SpecularRT : RENDERCOLORTARGET;
sampler2D SpecularRT_Samp = sampler_state {
    texture = <SpecularRT>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};

//Irradiance RT
shared texture2D IrradianceRT : RENDERCOLORTARGET;
sampler2D IrradianceRT_Samp = sampler_state {
    texture = <IrradianceRT>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};

#if APPLY_IBL == 1
//IBL
textureCUBE IBLMap  <
    string ResourceName = IBL_Texture
    string Format = "A16B16G16R16F";>;
sampler IBLSampler = sampler_state {
    Texture = <IBLMap>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = POINT;
    ADDRESSU  = CLAMP;
    ADDRESSV  = CLAMP;
    ADDRESSW  = CLAMP;
};
#if APPLY_IBL_SPECULAR == 1
//IBL 2
textureCUBE IBLMap2  <
    string ResourceName = IBL_Texture_2
    string Format = "A16B16G16R16F";>;
sampler IBLSampler2 = sampler_state {
    Texture = <IBLMap2>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = POINT;
    ADDRESSU  = CLAMP;
    ADDRESSV  = CLAMP;
    ADDRESSW  = CLAMP;
};

//IBL 3
textureCUBE IBLMap3  <
    string ResourceName = IBL_Texture_3
    string Format = "A16B16G16R16F";>;
sampler IBLSampler3 = sampler_state {
    Texture = <IBLMap3>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = POINT;
    ADDRESSU  = CLAMP;
    ADDRESSV  = CLAMP;
    ADDRESSW  = CLAMP;
};
#endif
#endif

#if APPLY_ALPHA_POST_PROCESSING == 1

#define AlphaRT_Control  "AlphaRT.x"
bool ART_Valid  : CONTROLOBJECT < string name = AlphaRT_Control; >;

//Alpha Map
shared texture2D AlphaMaskRT : RENDERCOLORTARGET;
sampler2D ART_Samp = sampler_state {
    texture = <AlphaMaskRT>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = ANISOTROPIC;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
	ADDRESSW  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

// This description is to avoid overwriting the original MMD sampler. Cannot be deleted.
sampler MMDSamp0 : register(s0);
sampler MMDSamp1 : register(s1);
sampler MMDSamp2 : register(s2);
////////////////////////////////////////////////////////////////////////////////////////////////
// Sequence of transformations
float4x4 WorldViewProjMatrix		: WORLDVIEWPROJECTION;
float4x4 WorldViewMatrix			: WORLDVIEW;
float4x4 WorldMatrix				: WORLD;
float4x4 ViewMatrix					: VIEW;
float4x4 LightWorldViewProjMatrix	: WORLDVIEWPROJECTION < string Object = "Light"; >;
float4x4 WorldViewMatrixInverse		: WORLDVIEWINVERSE;

float3 	LightDirection    : DIRECTION < string Object = "Light"; >;
float3	CameraPosition    : POSITION  < string Object = "Camera"; >;

// Material color
float4	MaterialDiffuse		: DIFFUSE  < string Object = "Geometry"; >;
#if APPLY_MATERIAL_AMBIENT == 0
static float3	MaterialAmbient = 1;
#endif
#if APPLY_MATERIAL_EMMISIVE == 0
static float3	MaterialEmmisive = 1;
#endif
#if APPLY_MATERIAL_AMBIENT == 1
float3	MaterialAmbient		: AMBIENT  < string Object = "Geometry"; >;
#endif
#if APPLY_MATERIAL_EMMISIVE == 1
float3	MaterialEmmisive	: EMISSIVE < string Object = "Geometry"; >;
#endif
float3	MaterialSpecular	: SPECULAR < string Object = "Geometry"; >;
float	SpecularPower		: SPECULARPOWER < string Object = "Geometry"; >;
float4	MaterialToon		: TOONCOLOR;
float4	EdgeColor			: EDGECOLOR;

// Light Color
float3	LightDiffuse			: DIFFUSE   < string Object = "Light"; >;
#if APPLY_LIGHT_AMBIENT == 0
static float3	LightAmbient_B = 1;
#endif
#if APPLY_LIGHT_AMBIENT == 1
float3	LightAmbient_B			: AMBIENT   < string Object = "Light"; >;
#endif
float3	LightSpecular			: SPECULAR  < string Object = "Light"; >;
static	float4 DiffuseColor		= MaterialDiffuse  * float4(LightDiffuse, 1.0f);
static	float3 SpecularColor	= MaterialSpecular * LightSpecular;
static	float3 LightAmbient		= (MaterialAmbient * LightAmbient_B * float(1.75) * MaterialEmmisive);

bool	parthf;   // Perspective flag
bool	transp;   // Semi-transparent flag
bool	spadd;    // Sphere map additive composition flag

#define	SKII1	1500
#define	SKII2	8000
#define	Toon	Toon_Gradient

//HG Shadow
#include "Resources/HgShadow_ObjHeader.fxh"

////////////////////////////////////////////////////////////////////////////////////////////////
//NormalMap
    #if APPLY_NORMALMAP == 1
float3x3 compute_tangent_frame(float3 N, float3 p, float2 uv)
{
    float3 dp1 = ddx( p );
    float3 dp2 = ddy( p );
    float2 duv1 = ddx( uv );
    float2 duv2 = ddy( uv );

    float3 dp2perp = cross( dp2, N );
    float3 dp1perp = cross( N, dp1 );
    #if FLIP_NORMALMAP == 1
    float3 T = (dp2perp * duv1.x + dp1perp * duv2.x);
    float3 B = (dp2perp * duv1.y + dp1perp * duv2.y);
	#endif
    #if FLIP_NORMALMAP == 0
    float3 T = -(dp2perp * duv1.x + dp1perp * duv2.x);
    float3 B = -(dp2perp * duv1.y + dp1perp * duv2.y);
    #endif
 
    float invmax = rsqrt( max( dot(T,T), dot(B,B) ) );
    return float3x3( T * invmax, B * -invmax, N );
}
    #endif
////////////////////////////////////////////////////////////////////////////////////////////////

#if APPLY_BILLBOARD == 1
static float3x3 BillboardMatrix = {
    normalize(WorldViewMatrixInverse[0].xyz),
    normalize(WorldViewMatrixInverse[1].xyz),
    normalize(WorldViewMatrixInverse[2].xyz),
};

float3 BillboardMB : CONTROLOBJECT < string name = Billboard_Model_Name ; string item = Billboard_Bone_Name ; >;

#endif

////////////////////////////////////////////////////////////////////////////////////////////////
// Edge Line

float4 ColorRender_VS(float4 Pos : POSITION) : POSITION 
{
    // World view projection transformation of camera viewpoint
    return mul( Pos, WorldViewProjMatrix );
}

// Pixel Shader
float4 ColorRender_PS() : COLOR
{
    // Edge Line Color
    return EdgeColor;
}

// Techniques
technique EdgeTec < string MMDPass = "edge"; > {
    pass DrawEdge {
        AlphaBlendEnable = FALSE;
        AlphaTestEnable  = FALSE;

        VertexShader = compile vs_2_0 ColorRender_VS();
        PixelShader  = compile ps_2_0 ColorRender_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////

sampler DefSampler : register(s0);

struct BufferShadow_INPUT {
    float4 Pos      : POSITION; // Position
    float3 Normal   : NORMAL; // Normal
    float3 Binormal	: BINORMAL; // Binormal
    float3 Tangent	: TANGENT; // Tangent
    float2 UV		: TEXCOORD0; // UV
    float2 UV1		: TEXCOORD1; // AO Map
	#if APPLY_VERTEXCOLOR == 1
    float4 UV2		: TEXCOORD2; // Vertex Color
	#endif
};

struct BufferShadow_OUTPUT {
	float4 Pos : POSITION;
    float3 Normal   : NORMAL; // Normal
    float4 Color    : COLOR0; // Texture
	float2 UV : TEXCOORD0;
	float2 UV1 : TEXCOORD1;
	#if APPLY_VERTEXCOLOR == 1
	float4 UV2 : TEXCOORD2;
	#endif
    float3 Eye      : TEXCOORD4; // Eye
    float4 ZCalcTex : TEXCOORD5; // ZCalcTex
    float4 PPos		: TEXCOORD8; // Positon for HgShadow
	#if APPLY_HEIGHTMAP == 1
	#if APPLY_HEIGHTMAP_TYPE == 0
	float4 PosWorld : TEXCOORD7;
	#endif
	#endif
};

///////////////////////////////////////////////////////////////////////////////////////////////
// Vertex Shader
BufferShadow_OUTPUT BufferShadow_VS(BufferShadow_INPUT IN)
{
	BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;
    
	// TEX
	Out.UV = IN.UV;
	Out.UV1 = IN.UV1;
	#if APPLY_VERTEXCOLOR == 1
	Out.UV2 = IN.UV2;
	#endif
	
	// Relative to the camera position
	Out.Eye = CameraPosition - mul( IN.Pos, WorldMatrix );	

	// Vertex Normal
	Out.Normal = normalize( mul( IN.Normal, (float3x3)WorldMatrix ) );
	
	// Shadow Projection
	Out.ZCalcTex = mul( IN.Pos, LightWorldViewProjMatrix );
	
	// Color
	Out.Color.rgb = 1;
	
	Out.Color.rgb += max(0,dot( IN.Normal, -LightDirection )) * DiffuseColor.rgb;
	
	Out.Color.a = DiffuseColor.a;
	Out.Color = saturate( Out.Color );
	
	//Billboard
	#if APPLY_BILLBOARD == 1
	IN.Pos.xyz = mul( IN.Pos.xyz, BillboardMatrix);
	IN.Pos.xyz += BillboardMB;
	#endif
	
	// World view projective transformation from camera perspective
	Out.Pos = mul( IN.Pos, WorldViewProjMatrix );

	#if APPLY_HEIGHTMAP == 1
	#if APPLY_HEIGHTMAP_TYPE == 1
	float HeightMap = tex2Dlod(HeightMap_Sampler, float4(IN.UV, 0,0)* HeightMap_Scale).x;
	IN.Pos.xyz += IN.Normal * (HeightMap * Height_Intensity);
	Out.Pos = mul(IN.Pos, WorldViewProjMatrix);
	#endif
	#endif
	
	#if APPLY_HEIGHTMAP == 1
	#if APPLY_HEIGHTMAP_TYPE == 0
	Out.PosWorld = mul( IN.Pos, WorldMatrix );
	#endif
	#endif
	
	// HgShadow
	Out.PPos = Out.Pos;
	
	return Out;
}

//////////////////////////////////////////////////
float3x3 Set_Rotation(float3 in_axis, float s, float c)
{
    float c_1 = 1.0f - c;
	float3x3 in_m1 = 1;
    float3 axis = normalize(in_axis);
    float3 axis_s = axis * s;

    float3 temp;
    temp = axis * axis.x * c_1;
    in_m1[0].x = temp.x + c;
    in_m1[1].x = temp.y - axis_s.z;
    in_m1[2].x = temp.z + axis_s.y;
    temp = axis * axis.y * c_1;
    in_m1[0].y = temp.x + axis_s.z;
    in_m1[1].y = temp.y + c;
    in_m1[2].y = temp.z - axis_s.x;
    temp = axis * axis.z * c_1;
    in_m1[0].z = temp.x - axis_s.y;
    in_m1[1].z = temp.y + axis_s.x;
    in_m1[2].z = temp.z + c;
	return in_m1;
}
//////////////////////////////////////////////////

	#if APPLY_TONE_MAP == 1
	
//////////////////////////////////////////////////
//ToneMap Controller 
#define CONTROLLER_NAME	"ToneMapPD Controller.pmx"

//Alpha
float Transparency : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Transparency"; >;

float Exp_Morph_Plus : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Exposure +"; >;
float Exp_Morph_Less : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Exposure -"; >;

float Saturation_Plus : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Saturation +"; >;
float Saturation_Less : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Saturation -"; >;

float Gama_Plus : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Gama +"; >;
float Gama_Less : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Gama -"; >;

float Brightness_Plus : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Brightness +"; >;
float Brightness_Less : CONTROLOBJECT < string name = "ToneMapPD Controller.pmx"; string item = "Brightness -"; >;

/////////////////////////////////////////////////////////////////////////////////
	
float2 yccLookup(float x)
{
    float v9 = 1.0;
    v9 *= 1 * Gama;
	v9 += 1;
	
    v9 *= 1.0 + Gama_Plus * float(2.20);
    v9 *= 1.0 - Gama_Less * float(0.8);
	
    float samples = 32;
    float scale = 1.0 / samples;
    float i = x * 16 * samples;
    float v11 = exp( -i * scale );
    float v10 = pow( 1.0 - v11, v9 );
    v11 = v10 * 2.0 - 1.0;
    v11 *= v11;
    v11 *= v11;
    v11 *= v11;
    v11 *= v11;
	samples *= Saturation;
	
	float SaturationP = Saturation_Plus;
	float SaturationL = Saturation_Less;
	samples *= 1 + SaturationP;
	samples *= 1 + -SaturationL;
	
	
	
    return float2( v10, v10 * ( samples / i ) * ( 1.0 - v11 ) );
}

float3 ColorToneMapping( float3 c)
{
    float exposure = 1.0;
	
	Exposure *= 1.0 + Exp_Morph_Plus * 4.0;
	Exposure *= 1.0 + -Exp_Morph_Less;
	
    exposure = 	lerp(exposure, Exposure, exposure);
	
    float4 color;
    color.rgb = c;

    color.y = dot( color.rgb, float3( 0.30, 0.59, 0.11 ) );
    color.rb -= color.y;
    color.yw = yccLookup( color.y * exposure * 0.0625 );
    color.rb *= exposure * color.w;
    color.w = dot( color.rgb, float3( -0.508475, 1.0, -0.186441 ) );
    color.rb += color.y;
    color.g = color.w;    
	return color.rgb;
}
#endif
/////////////////////////////////////////////////////////////////////////////////
#if APPLY_HEIGHTMAP == 1
#if APPLY_HEIGHTMAP_TYPE == 0
float3 ParallaxOcclusionDirection(float3 normal, float3 worldPos, float2 coord)
{
	float3 viewNormal = mul(normal, (float3x3)WorldViewMatrix);
	float3 viewPosition = mul(float4(worldPos, 1), WorldViewMatrix).xyz;
	float3 viewdir = normalize(-viewPosition);

	float3 dp1 = ddx(viewPosition);
	float3 dp2 = ddy(viewPosition);

	float2 duv1 = ddx(coord);
	float2 duv2 = ddy(coord);

	float3x3 M = float3x3(dp1, dp2, viewNormal);
	float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
	   
	float2 proj = mul(I, viewdir) / dot(dp1, I[0]);

	float3 direction;
	direction.xy = duv1 * proj.x + duv2 * proj.y;
	direction.z = dot(viewNormal, viewdir);

	return direction;
}

float2 ParallaxOcclusionMap(sampler2D heightMap, float2 coord, float3 V, int numSteps, float parallaxScale)
{
	float step = 1.0 / numSteps;
	float2 delta = parallaxScale * V.xy / (-V.z * numSteps);

	float curLayerHeight = 0;
	float curHeight = tex2D(heightMap, coord).r;
	float2 curTexcoord = coord;

	[unroll]
	for (int i = 0; i < numSteps; i++)
	{
		if (curHeight <= curLayerHeight)
			break;

		curLayerHeight += step; 
		curTexcoord -= delta;
		curHeight = tex2D(heightMap, curTexcoord).r;
	}

	float2 deltaTexcoord = delta * 0.5;
	float deltaHeight = step * 0.5;

	curTexcoord += deltaTexcoord;
	curLayerHeight -= deltaHeight;

	[unroll]
	for (int j = 0; j < 5; j++)
	{
		deltaTexcoord *= 0.5;
		deltaHeight *= 0.5;

		curHeight = tex2D(heightMap, curTexcoord).r;

		if (curHeight > curLayerHeight)
		{
			curTexcoord -= deltaTexcoord;
			curLayerHeight += deltaHeight;
		}
		else
		{
			curTexcoord += deltaTexcoord;
			curLayerHeight -= deltaHeight;
		}
	}

	return curTexcoord;
}
#endif
#endif
////////////////////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
float4 BufferShadow_PS(BufferShadow_OUTPUT IN) : COLOR
{
//////////////////////////////////////////////////
// Inputs
	float2 UV			= IN.UV;
	float2 UV1			= IN.UV1;
//////////////////////////////////////////////////
// Parallax
	#if APPLY_HEIGHTMAP == 1
	#if APPLY_HEIGHTMAP_TYPE == 0
	float3 ParallaxViewDirection = ParallaxOcclusionDirection(IN.Normal, IN.PosWorld.xyz, UV);
	UV = ParallaxOcclusionMap(HeightMap_Sampler, UV, ParallaxViewDirection, 15, Height_Intensity);
	#endif
	#endif
//////////////////////////////////////////////////
	float3 Normal		= normalize(IN.Normal);
    float3 HalfVector	= normalize( normalize(IN.Eye) + -LightDirection );
	float3 Eye			= normalize(IN.Eye);
//////////////////////////////////////////////////
	
	float3x3 RotationTransform;

	float length1 = length(LightDirection.xyz * float3(1, -1, -1));
    if (length1 >= 0.000001f) {
        float3 cube_direction = (LightDirection.xyz * float3(1, -1, -1)) * (1.0f / length1);

		float3 Posi = float3(0, 1, 0);
        length1 = length(Posi.xyz);
        if (length1 >= 0.000001f) {
            float3 position = Posi * (1.0f / length1);
		
			float3 axis = cross(cube_direction, position);
            length1 = length(axis.xyz);

            float v52 = dot(cube_direction, position);
            float angle = abs(atan2(length1, v52));
			
			if (angle >= 0.01f && angle <= 3.131592653589793f) {
                if (length1 != 0.0f)
                    axis *= 1.0f / length1;
				
			RotationTransform =  Set_Rotation(axis, sin(-angle), cos(-angle));
			}
		}
	}
	
	float Eyerot_x = radians(22.5);
    float Eyerot_y = radians(-22.5);
    float Eyerot_z = radians(45);
	
	float3x3 EyeRotationX = {
	    {1,	0,	0},
	    {0, cos(Eyerot_x), sin(Eyerot_x)},
	    {0, -sin(Eyerot_x), cos(Eyerot_x)},
	};
	float3x3 EyeRotationY = {
	    {cos(Eyerot_y), 0, -sin(Eyerot_y)},
	    {0, 1, 0},
		{sin(Eyerot_y), 0,cos(Eyerot_y)},
	    };
	float3x3 EyeRotationZ = {
	    {cos(Eyerot_z), sin(Eyerot_z), 0},
	    {-sin(Eyerot_z), cos(Eyerot_z), 0},
	    {0, 0, 1},
	};
	float3x3 EyeRot = RotationTransform;
    EyeRot = mul( EyeRot, EyeRotationX );
    EyeRot = mul( EyeRot, EyeRotationY );
    EyeRot = mul( EyeRot, EyeRotationZ );
	float3 EyeL = mul(Eye, (float3x3)EyeRot);

//////////////////////////////////////////////////
    float4 Color		= IN.Color;
	
	Color.rgb *= LightAmbient + 0.5 * saturate(LightAmbient);
	
	float4 TexColor		= tex2D( ObjTexSampler, UV );
	
//////////////////////////////////////////////////
    float4 ShadowColor	= 1;
	
	#if APPLY_SHADER_SHADOW_COLOR == 0
	
	if(SSS_Valid){
	ShadowColor.rgb = lerp(ShadowColor.rgb, Shadow_Color * MaterialToon,Shadow_Color.a);
	}else{
    ShadowColor	= MaterialToon;
	}
	
	#endif
	
	#if APPLY_SHADER_SHADOW_COLOR == 1

	if(SSS_Valid){
	ShadowColor.rgb = lerp(ShadowColor.rgb, Shadow_Color * MaterialToon,Shadow_Color.a);
	}else{
	ShadowColor.rgb = lerp(ShadowColor.rgb, Shadow_Color * MaterialToon,Shadow_Color.a);
	}
	
	#endif
//////////////////////////////////////////////////
//Front and Back Light

	#if APPLY_BACK_LIGHT  == 1
	float3 Back_Light		= pow( max(0,dot( (LightDirection * float3 (1.0,-1.0,1.0)), Normal )), Back_Light_Size ) * TexColor  * Back_Light_Color;
	#endif
	#if APPLY_FRONT_LIGHT == 1
	float3 Front_Light		= pow( max(0,dot( -LightDirection, Normal )), Front_Light_Size ) * TexColor * Front_Light_Color;
	#endif
//////////////////////////////////////////////////

	#if APPLY_NORMALMAP == 1
	float3 NormalMap		= tex2D( NormalMapSampler, UV).xyz * 2;		
	float3x3 tangentFrame	= compute_tangent_frame(Normal, Eye, IN.UV);
	NormalMap.z				-= NormalMap_Intensity;
	Normal					= normalize(mul(NormalMap.xyz - 1.0f, tangentFrame));
	#endif
	
//////////////////////////////////////////////////
//Specular Map

	#if APPLY_SPECULARMAP == 1
	float4 SpecularMap = tex2D(SpecularMapSampler, UV);
	#endif

//////////////////////////////////////////////////
//Specular

	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	
	#if APPLY_SHADER_SPECULAR == 0
    float3 Specular		= pow( max(0,dot( HalfVector, Normal)), SpecularPower ) * SpecularColor;
	#endif

	#if APPLY_SHADER_SPECULAR == 1
	float3 Specular		= pow( max(0,dot( HalfVector, Normal )), Specular_Shininess );
	#endif
	
	#if APPLY_SPECULARMAP == 1
	Specular.rgb		*= SpecularMap.rgb + SpecularMap.rgb;
	#endif
	
	#if APPLY_SHADER_SPECULAR == 1
	Specular.rgb *= Specular_Color.rgb;
	#endif
	
	Specular *= 1.5 * LightAmbient;
	
	#endif
	#endif

//////////////////////////////////////////////////
//RimLight
	
	#if APPLY_RIMLIGHT_TYPE == 1
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 0
	float3 RimEye = Eye;
	#endif
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 1
	float3 RIMDIR = Eye;
	
	RIMDIR.x += LightDirection.x;
	RIMDIR.y += LightDirection.y;
	
	float3 RimEye = normalize(Eye + RIMDIR);
	#endif
	
	#if APPLY_RIMLIGHT_TYPE == 1
	#if APPLY_SHADER_SPECULAR == 0
	float4 RimLight		= saturate(pow( 1 - dot(Normal, RimEye), 1 * SpecularPower * float(0.5) ) * float4(SpecularColor.rgb,0));
	#endif
	#endif
	
	#if APPLY_RIMLIGHT_TYPE == 1
	#if APPLY_SHADER_SPECULAR == 1
	float3 RimLight		= saturate(pow( 1 - dot(Normal, RimEye), 1 * Specular_Shininess * float(0.5) ) * float4(Specular_Color.rgb,0));
	#endif
	#endif
	
	#if APPLY_SPECULARMAP == 1
	RimLight.rgb *= SpecularMap.rgb + SpecularMap.rgb;
	#endif
	
	RimLight.rgb *= 1.5 * LightAmbient;
	
	#endif
	
//////////////////////////////////////////////////
//Custom RimLight
	
	#if APPLY_RIMLIGHT_TYPE == 3
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 0
	float3 RimCEye = Eye;
	#endif
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 1
	float3 RIMCDIR = Eye;
	
	RIMCDIR.x += LightDirection.x;
	RIMCDIR.y += LightDirection.y;
	
	float3 RimCEye = normalize(Eye + RIMCDIR);
	#endif
	
	float4 RimLightC		= saturate(pow( 1 - dot(Normal, RimCEye), Custom_RimLight_Size / 10 ) * float4(Custom_RimLight_Color.rgb,0));
	
	RimLightC.rgb *= 1.5 * LightAmbient;
	
	#endif
	
//////////////////////////////////////////////////
//SPA
	
	#if APPLY_SPA == 1
	float2 sphTex = mul( Normal, (float3x3)ViewMatrix ).xyz;
	sphTex.x = sphTex.x * 0.5f + 0.5f;
	sphTex.y = sphTex.y * -0.5f + 0.5f;
	float4 SPAMap = tex2D(ObjSphareSampler,sphTex) * 1;
	
	#if APPLY_SPECULARMAP == 1
	SPAMap.rgb *= SpecularMap.a;
	#endif

	SPAMap.rgb *= Specular_Color.a;

	#endif
	
//////////////////////////////////////////////////
//Cubemap
	#if APPLY_CUBEMAP == 1
	
	#if APPLY_CUBEMAP == 1
	#if APPLY_CUBEMAP_LIGHT_DIRECTION == 0
	float3 CubeMapReflection = reflect(Normal, Eye);
	#endif
	#endif
	
	#if APPLY_CUBEMAP == 1
	#if APPLY_CUBEMAP_LIGHT_DIRECTION == 1
	float3 CubeMapReflection = reflect(Normal * float3(1,1,-1), EyeL);
	#endif
	#endif
	
	float4 CubeMap = texCUBE(CubeMapSampler, CubeMapReflection);
	
	#if APPLY_SPECULARMAP == 1
	CubeMap.rgb *= SpecularMap.a;
	#endif

	CubeMap.rgb *= Specular_Color.a;

	#endif
//////////////////////////////////////////////////
//REFRACTION

	#if APPLY_REFRACTION == 1
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_LIGHT_DIRECTION == 0
	float3 Refract = refract(Eye, -Normal, 1.0/Refraction_Index).xyz;
	#endif
	#endif
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_LIGHT_DIRECTION == 1
	float3 Refract = refract(EyeL, -Normal * float3(1,1,-1), 1.0/Refraction_Index).xyz;
	#endif
	#endif
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 0
	Refract = -Refract.xzy;
	Refract.z = -Refract.z;
	#endif
	#endif
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 1
	Refract.y = -Refract.y;
	#endif
	#endif
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 0
	float4 RefractedColor = texCUBE(Refraction_Sampler, Refract) * Refraction_Intensity;
	#endif
	#endif

	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 1
	float4 RefractedColor = texDP(sampEnvMapF, sampEnvMapB, Refract) * Refraction_Intensity;
	#endif
	#endif
	
		#if APPLY_REFRACTION == 1
		#if APPLY_REFRACTION_SPECULARMAP == 1
		#if APPLY_SPECULARMAP == 1
		RefractedColor.rgb *= SpecularMap.a;
		#endif
		#endif
		#endif
		
	#endif
	
//////////////////////////////////////////////////
//Fresnel

	#if APPLY_RIMLIGHT_TYPE == 2
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 0
	float3 FresnelEye = Eye;
	#endif
	
	#if APPLY_RIMLIGHT_LIGHT_DIRECTION == 1
	float3 FRESNELDIR = Eye;
	
	FRESNELDIR.x += LightDirection.x;
	FRESNELDIR.y += LightDirection.y;
	
	float3 FresnelEye = normalize(Eye + FRESNELDIR);
	#endif
	
	#if APPLY_SHADER_SPECULAR == 0
	float3 Fresnel = saturate(pow( 1 - dot(Normal, FresnelEye), 1 * SpecularPower * float(0.5) )  * Specular_Color.a);
	#endif
	#if APPLY_SHADER_SPECULAR == 1
	float3 Fresnel = saturate(pow( 1 - dot(Normal, FresnelEye), 1 * Specular_Shininess * float(0.5) ) * Specular_Color.a);
	#endif
	
	#if APPLY_CUBEMAP == 1
	float4 CubeMapF = texCUBE(CubeMapSampler, CubeMapReflection);
	
	CubeMapF.rgb *= Specular_Color.a;
	
	Fresnel *= CubeMapF;
	#endif
	
	#if APPLY_SPA == 1
	float4 SPAMapF = tex2D(ObjSphareSampler,sphTex) * 1;
	
	Fresnel.rgb *= SPAMapF.a;
	#endif
	
	#if APPLY_REFRACTION == 1
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 0
	float4 RefractedColorF = texCUBE(Refraction_Sampler, Refract) * Refraction_Intensity;
	#endif
	#endif
	
	#if APPLY_REFRACTION == 1
	#if APPLY_REFRACTION_REFLECTION == 1
	float4 RefractedColorF = texDP(sampEnvMapF, sampEnvMapB, Refract) * Refraction_Intensity;
	#endif
	#endif
	
	Fresnel.rgb *= RefractedColorF.a;
	
	#endif
	
	#if APPLY_SPECULARMAP == 1
	Fresnel.rgb *= lerp(Fresnel , Fresnel, SpecularMap.a);
	#endif
	
	Fresnel.rgb *= 1.5 * LightAmbient;
	
	#endif

//////////////////////////////////////////////////
//Aniso

	#if APPLY_ANISO == 1
	float3 Aniso;

	if(Aniso_Valid){
	float2 AnisoCoord = float2( ( IN.PPos.x/IN.PPos.w + 1.0f ) * 0.5f, 1.0f - ( IN.PPos.y/IN.PPos.w + 1.0f ) * 0.5f ) + 2;
	float4 ANISO_X = tex2D(Aniso_Samp, AnisoCoord);
	
	ANISO_X.yz = pow(ANISO_X.yz, Aniso_Size * 5);

    float2 aniso_coef;
    aniso_coef = float2(dot(Normal, -LightDirection.xyz).xx) * float2(0.7, -0.7) + float2(0.3, 0.3);
    aniso_coef = ANISO_X.yz * clamp(aniso_coef, (0.0), (1.0)) * float2(0.18, 0.05);

    Aniso = aniso_coef.x * 3.1 + (Aniso_Back.rgb + 2 * aniso_coef.y);

	Aniso.rgb *= Specular_Color;
	} else {
	float3 AnisoPos = 1;

	float3 AnisoR = AnisoPos;
	
	AnisoPos.x -= Aniso_Pos_X;
	AnisoPos.y -= Aniso_Pos_Y;
	AnisoPos.x -= 1;
	AnisoPos.y -= 1;
	
	float3 AnisoPose = mul(AnisoPos.xy, ViewMatrix);
	
	AnisoPose.x += LightDirection.x;
	AnisoPose.y += LightDirection.y;
	
	float3 h = normalize(Eye + AnisoPose);
	
	h.x = -h.x;
	h.y = -h.y;
	
	float HdotA = dot(normalize(normalize (Normal)), h);
	
	#if APPLY_SHADER_SPECULAR == 0
	Aniso = max(Aniso_Back, sin(radians((HdotA + 0) * 180)* Aniso_Size));
	Aniso.rgb *= SpecularColor;
	#endif

	#if APPLY_SHADER_SPECULAR == 1
	Aniso = max(Aniso_Back, sin(radians((HdotA + 0) * 180)* Aniso_Size));
	Aniso.rgb *= Specular_Color;
	#endif
	
	float AnisoIntensitySmooth = smoothstep(0.0, Aniso_Softness, 1);
	
	Aniso = AnisoIntensitySmooth * Aniso;
	}
	
		#if APPLY_SPECULARMAP == 1
		float3 SpecularMapA = SpecularMap.rgb + SpecularMap.rgb;
		SpecularMapA += Aniso * SpecularMapA;
		Aniso *= SpecularMapA.rgb;
		#endif
		
		Aniso *= 1.5  * LightAmbient;
	
	#endif

//////////////////////////////////////////////////
//Custom RimLight
	
	#if APPLY_RIMSHADOW == 1
	
	#if APPLY_RIMSHADOW_LIGHT_DIRECTION == 0
	float3 RimS1DIR = Eye;
	RimS1DIR.y += 1 + Eye;
	RimShadow_Direction += (1 - Eye);
	RimS1DIR.y -= RimShadow_Direction + (Eye.x);
	RimS1DIR.x -= RimShadow_Direction;
	
	float3 RimS1Eye = normalize(Eye + RimS1DIR);
	
	#endif
	
	#if APPLY_RIMSHADOW_LIGHT_DIRECTION == 1
	float3 RimS1DIR = Eye;
	
	RimS1DIR.y += 1 + Eye;
	RimShadow_Direction += (1 - Eye);
	RimS1DIR.y -= RimShadow_Direction + (Eye.x) + (LightDirection.y * float( 1 - RimShadow_Direction + 2));
	RimS1DIR.x -= RimShadow_Direction + (LightDirection.x * float( 1 - RimShadow_Direction * 2));
	
	float3 RimS1Eye = normalize(Eye + RimS1DIR);
	#endif
	
	float4 RimShadow = saturate(pow( 1 - dot(Normal, RimS1Eye), RimShadow_Size / 10 )) * RimShadow_Intensity;
	
	float RimShadowSmooth = smoothstep(0.0, RimShadow_Smooth, 1);
	
	RimShadow = RimShadowSmooth * RimShadow;
	
	RimShadow.rgb *= RimShadow_Color;
	
	RimShadow.rgb *= 1.5  * LightAmbient;
	
	Color.rgb -= 0 + RimShadow.rgb;
	
	
	#endif
	
//////////////////////////////////////////////////
//Texture

		Color.rgb *= TexColor.rgb * Texture_Brightness;

//////////////////////////////////////////////////
// Final Colors

	#if APPLY_TINT == 0
	
	float3 Ref = 0;
	
	#if APPLY_BACK_LIGHT == 1
	Color.rgb = lerp(Color.rgb,1,Back_Light);
	#endif
	#if APPLY_FRONT_LIGHT == 1
	Color.rgb = lerp(Color.rgb,1,Front_Light);
	#endif
	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	Ref.rgb = lerp(Ref.rgb,1,Specular);
	#endif
	#endif
	#if APPLY_SPA == 1
	Color.rgb = lerp(Color.rgb,1,SPAMap);
	#endif
	#if APPLY_RIMLIGHT_TYPE == 1
	Ref.rgb = lerp(Ref.rgb,1,RimLight);
	#endif
	#if APPLY_CUBEMAP == 1
	Color.rgb = lerp(Color.rgb,1,CubeMap);
	#endif
	#if APPLY_REFRACTION == 1
	Ref.rgb = lerp(Ref.rgb,1,RefractedColor);
	#endif
	#if APPLY_RIMLIGHT_TYPE == 2
	Ref.rgb = lerp(Ref.rgb,1,Fresnel);
	#endif
	#if APPLY_RIMLIGHT_TYPE == 3
	Ref.rgb = lerp(Ref.rgb,1,RimLightC);
	#endif
	#if APPLY_ANISO == 1
	Ref.rgb = lerp(Ref.rgb,1,Aniso);
	#endif
	
	#if SHADOW_AFFECT_SPECULAR_REFLECTIONS == 0
	Color.rgb = lerp(Color.rgb,1,Ref);
	#endif
	
	#endif
	
	#if APPLY_TINT == 1
	
	float3 Ref = 0;
	
	#if APPLY_BACK_LIGHT == 1
	Color.rgb += Back_Light;
	#endif
	#if APPLY_FRONT_LIGHT == 1
	Color.rgb += Front_Light;
	#endif
	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	Ref.rgb += Specular;
	#endif
	#endif
	#if APPLY_SPA == 1
	Color.rgb += SPAMap;
	#endif
	#if APPLY_RIMLIGHT_TYPE == 1
	Ref.rgb += RimLight;
	#endif
	#if APPLY_CUBEMAP == 1
	Color.rgb += CubeMap;
	#endif
	#if APPLY_REFRACTION == 1
	Color.rgb += RefractedColor;
	#endif
	#if APPLY_RIMLIGHT_TYPE == 2
	Ref.rgb += Fresnel;
	#endif
	#if APPLY_RIMLIGHT_TYPE == 3
	Ref.rgb += RimLightC;
	#endif
	#if APPLY_ANISO == 1
	Ref.rgb += Aniso;
	#endif
	
	#if SHADOW_AFFECT_SPECULAR_REFLECTIONS == 0
	Color.rgb += Ref;
	#endif
	
	#endif
	
//////////////////////////////////////////////////
// Vertex Color

	#if APPLY_VERTEXCOLOR == 1
	float4 UV2			= IN.UV2;
	float4 VertexColor = IN.UV2;
	Color.rgb = lerp(Color.rgb, Color.rgb * VertexColor.rgb,VertexColor_Intensity);
	#endif
	
//////////////////////////////////////////////////
// Ambient Occlussion

	#if APPLY_AMBIENTOCCLUSSION == 1
	
	#if APPLY_AMBIENTOCCLUSSION_UV == 1
	float2 UVAO = UV;
	#endif
	#if APPLY_AMBIENTOCCLUSSION_UV == 0
	float2 UVAO = UV1;
	#endif
	float4 AmbientOcclussion = tex2D(AO_Sampler, UVAO);

	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 0
	AmbientOcclussion.rgb += Ambient_Occlussion_Color;
	#endif
	
	#if AMBIENTOCCLUSSION_TYPE == 1
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 0
	Color = lerp(Color, Color * AmbientOcclussion * AmbientOcclussion,(1 - AmbientOcclussion) * Ambient_Occlussion_Intensity);
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if R_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb * float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).r * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if G_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb * float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).g * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if B_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb * float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).b * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#endif
	
	#if AMBIENTOCCLUSSION_TYPE == 2
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 0
	Color = lerp(Color, Color + AmbientOcclussion,(1 - AmbientOcclussion) * Ambient_Occlussion_Intensity);
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if R_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb * float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).r * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if G_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb * float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).g * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#if APPLY_AMBIENTOCCLUSSION_RGB_CHANNELS == 1
	#if B_CHANNEL_AMBIENTOCCLUSSION == 1
	Color.rgb = lerp(Color.rgb, Color.rgb + float3(Ambient_Occlussion_Color),(1 - AmbientOcclussion).b * Ambient_Occlussion_Intensity);
	#endif
	#endif
	
	#endif
	#endif
	
//////////////////////////////////////////////////
		//ALPHA
		#if APPLY_ALPHA == 1
		Color.a = TexColor.a;
		#endif

//////////////////////////////////////////////////
//Transparency

	#if APPLY_TRANSPARENCY == 1
	float4 TransparencyMap = tex2D(Transparency_Sampler, UV);
	#endif

//////////////////////////////////////////////////
//Alpha Mask

	#if APPLY_ALPHA_MASK == 1
	
	#if APPLY_ALPHA_MASK_UV == 0
	float2 UVA = UV;
	#endif
	#if APPLY_ALPHA_MASK_UV == 1
	float2 UVA = UV1;
	#endif
	
	#if APPLY_ALPHA_MASK_RGB_CHANNELS == 0
	#if APPLY_ALPHA_MASK_RGB_CHANNELS == 0
	float AlphaMask = tex2D(Alpha_Mask_Sampler, UVA);
	#endif
	#if APPLY_ALPHA_MASK_RGB_CHANNELS == 1
	float3 AlphaMask = tex2D(Alpha_Mask_Sampler, UVA);
	#endif
	#endif
	#if APPLY_ALPHA_MASK_RGB_CHANNELS == 1
	float3 AlphaMask = tex2D(Alpha_Mask_Sampler, UVA);
	#endif
	#endif

//////////////////////////////////////////////////

		#if APPLY_TRANSPARENCY == 1
		
		float3 TRENDER = (pow( dot( Normal , Eye ), 1));
		
		float3 TEYEDIR = dot( Normal, -Eye.y);
		float3 TEYEDIR1 = dot( Normal, Eye.y);
		
		#if TRANSPARENCY_COLOR_TYPE == 0
		TransparencyMap.rgb	*= TransparencyMap + (0.9647058823529412, 0.8196078431372549, 0.7490196078431373);
		#endif
		
		#if TRANSPARENCY_COLOR_TYPE == 1
		TransparencyMap.rgb	*= TransparencyMap.rgb + Transparency_Color.rgb;
		TransparencyMap.rgb	*= Transparency_Color.a;
		#endif
		
		TRENDER = lerp( TRENDER.rgb, TRENDER.rgb, TRENDER.rgb + normalize(TEYEDIR * TEYEDIR1));
		
		TransparencyMap.rgb = lerp(TransparencyMap.rgb, TransparencyMap.rgb * TRENDER.rgb, Transparency_Intensity);
		
		Color.a   += TransparencyMap.a;
		
		Color.rgb = lerp(Color.rgb, Color.rgb * TransparencyMap.rgb, 1);
		#endif

//////////////////////////////////////////////////

		#if APPLY_ALPHA_MASK == 1
		
		#if APPLY_ALPHA_MASK_RGB_CHANNELS == 0
		Color.a   *= AlphaMask;
		#endif
	
		#if APPLY_ALPHA_MASK_RGB_CHANNELS == 1
		#if R_CHANNEL_ALPHA_MASK == 1
		Color.a   *= AlphaMask.r;
		#endif
		#endif
	
		#if APPLY_ALPHA_MASK_RGB_CHANNELS == 1
		#if G_CHANNEL_ALPHA_MASK == 1
		Color.a   *= AlphaMask.g;
		#endif
		#endif
	
		#if APPLY_ALPHA_MASK_RGB_CHANNELS == 1
		#if B_CHANNEL_ALPHA_MASK == 1
		Color.a   *= AlphaMask.b;
		#endif
		#endif
		
		#endif
	
//////////////////////////////////////////////////
	
	#if APPLY_ALPHA == 1
	
	#if APPLY_VERTEXCOLOR == 1
	Color.a *= VertexColor.a;
	#endif
	
	#endif
	
//////////////////////////////////////////////////
// Alpha Color
	
	#if APPLY_ALPHA == 1
	#if APPLY_COLOR_ALPHA == 1
	
    if((Alpha_Color_Intensity) > 0.0f){
	float len = length(Color.rgb - saturate(Alpha_Color));
	if( len <= (Alpha_Color_Intensity) ) Color.a = 0;
    }
	
	#endif
	#endif

//////////////////////////////////////////////////

		#if APPLY_ALPHA_CLIP == 1
		clip(Color.a < Alpha_Clip ? -1:1);
		#endif

//////////////////////////////////////////////////
//Over Transparency
		#if APPLY_OVER_TRANSPARENCY == 1
		
		#if APPLY_ANISO == 0
		#if APPLY_SPECULAR == 1
		Color.a    += Specular;
		#endif
		#endif
		
		#if APPLY_SPA == 1
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += SPAMap;
		#endif
		#endif

		#if APPLY_CUBEMAP == 1
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += CubeMap;
		#endif
		#endif

		#if APPLY_RIMLIGHT_TYPE == 1
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += RimLight;
		#endif
		#endif

		#if APPLY_RIMLIGHT_TYPE == 2
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += Fresnel;
		#endif
		#endif

		#if APPLY_RIMLIGHT_TYPE == 3
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += RimLightC;
		#endif
		#endif

		#if APPLY_REFRACTION == 1
		#if APPLY_OVER_TRANSPARENCY == 1
		Color.a    += RefractedColor;
		#endif
		#endif

		#if APPLY_ANISO == 1
		Color.a    += Aniso;
		#endif

		#endif
//////////////////////////////////////////////////
	
	#if APPLY_ALPHA_POST_PROCESSING == 1
	if(ART_Valid){
	clip(Color.a < 0.1 ? -1:1);
	
	float2 texCoord = float2( ( IN.PPos.x/IN.PPos.w + 1.0f ) * 0.5f, 1.0f - ( IN.PPos.y/IN.PPos.w + 1.0f ) * 0.5f ) + 2;
	float4 AlphaMaskRT = tex2Dlod(ART_Samp, float4(texCoord.xy, 0, 1));

	Color.a += AlphaMaskRT * AlphaMaskRT.a;
	}
	#endif
	
	#if APPLY_ALPHA == 1
	Color.a *= DiffuseColor.a;
	ShadowColor.a *= DiffuseColor.a;
	#endif
	
//////////////////////////////////////////////////
//Shadow
//////////////////////////////////////////////////
    // Convert to texture coordinates
    IN.ZCalcTex /= IN.ZCalcTex.w;
    float2 TransTexCoord;
    TransTexCoord.x = (1.0f + IN.ZCalcTex.x)*0.5f;
    TransTexCoord.y = (1.0f - IN.ZCalcTex.y)*0.5f;
    
		if( any( saturate(TransTexCoord) != TransTexCoord ) ) {
        return Color;
		} else {
        float ShadowComp = 0;
		float U = SoftShadowParam / SHADOWMAP_SIZE;
		float V = SoftShadowParam / SHADOWMAP_SIZE;
        if(parthf) {
            // セルフシャドウ mode2
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,0)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,0)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,0)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,-V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,-V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,-V)).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
        } else {
            // セルフシャドウ mode1
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,0)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,0)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,0)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,V)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(0,-V)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,V)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,V)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(-U,-V)).r , 0.0f)*SKII1-0.3f);
	        ShadowComp += saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord+float2(U,-V)).r , 0.0f)*SKII1-0.3f);
        }
        float LightNormal = dot(normalize(Normal), -LightDirection);
		
        float SHADSmooth = smoothstep(0.0, Toon_Smooth, 1);
        LightNormal = SHADSmooth * LightNormal;
		
        ShadowComp = 1-saturate(ShadowComp/9);
		ShadowComp = min(saturate(LightNormal * Toon), ShadowComp);

//////////////////////////////////////////////////
	if(HgShadow_Valid)
	{
        float comp = HgShadow_GetSelfShadowRate(IN.PPos);
         comp = min(saturate(LightNormal * Toon), comp);
	     ShadowComp = comp;
	}

//////////////////////////////////////////////////
// IBL
	if(IBLRT_Valid)
	{
	
 	#if APPLY_SUBSURFACETOON == 0
	float2 texCoord = float2( ( IN.PPos.x/IN.PPos.w + 1.0f ) * 0.5f, 1.0f - ( IN.PPos.y/IN.PPos.w + 1.0f ) * 0.5f ) + 2;
	
	float4 IBL = tex2Dlod(IBLRT_Samp, float4(texCoord.xy, 0, 1)) * 0.5 * IBL_Brightness;
		if(SSS_Valid)
	{
	float4 IBL1 = tex2Dlod(IBLRT_Samp, float4(texCoord.xy, 0, 1)) * 0.5;
	float3 IBL_B		= pow( max(0,dot( (LightDirection * float3 (1.0,-1.0,1.0)), Normal )), 1 );
	IBL1.rgb *= IBL_B.rgb;
	ShadowColor.rgb = lerp(ShadowColor.rgb, ShadowColor.rgb + IBL1,IBL_Intensity);
	} else {
	float4 IBL1 = tex2Dlod(IBLRT_Samp, float4(texCoord.xy, 0, 1)) * 1.25;
	float3 IBL_B		= pow( max(0,dot( (LightDirection * float3 (1.0,-1.0,1.0)), Normal )), 1 );
	IBL1.rgb *= IBL_B.rgb;
	ShadowColor.rgb = lerp(ShadowColor.rgb, ShadowColor.rgb + IBL1,IBL_Intensity);
	}

	#if APPLY_IBL_SPECULAR == 1
	
	float4 IBL2 = tex2Dlod(SpecularRT_Samp, float4(texCoord.xy, 0, 1)) * IBL_Brightness;
	float4 IBL3 = tex2Dlod(IrradianceRT_Samp, float4(texCoord.xy, 0, 1)) * IBL_Brightness;
	
    IBL2.rgb = IBL2.rgb + -IBL3.rgb;
    float4 IBL4 = lerp((IBL2 + IBL3) , 0, IBL_Brightness / 100);
	#endif
	
	#if APPLY_IBL_LIGHT_AMBIENT == 1
	
	IBL.rgb *= LightAmbient.rgb + 0.5;
	
	#if APPLY_IBL_SPECULAR == 1
	IBL4.rgb *= LightAmbient.rgb + 0.5;
	#endif
	#endif
	
	Color.rgb = lerp(Color.rgb, Color.rgb * IBL.rgb, 0.25 * IBL_Intensity);
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	Specular.rgb = lerp(Specular.rgb, Specular.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	#endif
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 1
	Aniso.rgb = lerp(Aniso.rgb, Aniso.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	
	#endif
	
	
	} else {
	//////////////////////////////////////////////////
	// OG IBL
	if(SSS_Valid)
	{
	#if APPLY_IBL == 1
	#if APPLY_IBL_SPECULAR == 1
	float2 texCoord2 = float2( ( IN.PPos.x/IN.PPos.w + 1.0f ) * 0.5f, 1.0f - ( IN.PPos.y/IN.PPos.w + 1.0f ) * 0.5f ) + 2;
    float4 IBL2 = tex2Dlod(SSS_Samp, float4(texCoord2, 0, 1));
	
	float IBL2TC = (IBL2.r+IBL2.g+IBL2.b)/3;
	float4 IBL2C = float4(IBL2TC,IBL2TC,IBL2TC,IBL2.a);
		
	IBL2 = lerp(IBL2C, IBL2, IBL2.a * 0.0);
	
	float4 IBL3 = texCUBElod(IBLSampler2, float4(EyeL, 0));
    IBL2.rgb = texCUBElod(IBLSampler3, float4(EyeL, 0));
    IBL2.rgb = IBL2.rgb + -IBL3.rgb;
    float4 IBL4 = lerp((IBL2 + IBL3) , 0, IBL_Brightness / 100);
	
	#if APPLY_IBL_LIGHT_AMBIENT == 1
	IBL4.rgb *= LightAmbient.rgb + 0.5;
	#endif
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	Specular.rgb = lerp(Specular.rgb, Specular.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	#endif
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 1
	Aniso.rgb = lerp(Aniso.rgb, Aniso.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	
	#endif
	#endif
	} else {
	#if APPLY_IBL == 1
	
	#if APPLY_IBL_LIGHT_DIRECTION == 0
	float3 IBLPos = Normal * float3(1,1,-1);
	#endif
	
	#if APPLY_IBL_LIGHT_DIRECTION == 1
    float IBLrot_x = radians(22.5);
    float IBLrot_y = radians(-22.5);
    float IBLrot_z = radians(45);
	float3x3 IBLRotationX = {
	    {1,	0,	0},
	    {0, cos(IBLrot_x), sin(IBLrot_x)},
	    {0, -sin(IBLrot_x), cos(IBLrot_x)},
	};
	float3x3 IBLRotationY = {
	    {cos(IBLrot_y), 0, -sin(IBLrot_y)},
	    {0, 1, 0},
		{sin(IBLrot_y), 0,cos(IBLrot_y)},
	    };
	float3x3 IBLRotationZ = {
	    {cos(IBLrot_z), sin(IBLrot_z), 0},
	    {-sin(IBLrot_z), cos(IBLrot_z), 0},
	    {0, 0, 1},
	};
	float3x3 IBLRot = RotationTransform;
    IBLRot = mul( IBLRot, IBLRotationX );
    IBLRot = mul( IBLRot, IBLRotationY );
    IBLRot = mul( IBLRot, IBLRotationZ );
	float3 IBLPos = mul(Normal* float3(1,1,-1), (float3x3)IBLRot);
	#endif
	
	float4 IBL = texCUBElod(IBLSampler, float4( IBLPos, 0)) * 0.5 * IBL_Brightness;
	float4 IBL1 = texCUBElod(IBLSampler, float4( IBLPos, 0)) * 1.25;
	
	#if APPLY_IBL_SPECULAR == 1
    float4 IBL2 = texCUBElod(IBLSampler, float4(Normal, 1));
	
	float4 IBL3 = texCUBElod(IBLSampler2, float4(EyeL, 0));
    IBL2.rgb = texCUBElod(IBLSampler3, float4(EyeL, 0));
    IBL2.rgb = IBL2.rgb + -IBL3.rgb;
    float4 IBL4 = lerp((IBL2 + IBL3) , 0, IBL_Brightness / 100);
	#endif
	
	#if APPLY_IBL_LIGHT_AMBIENT == 1
	
	IBL.rgb *= LightAmbient.rgb + 0.5;
	
	#if APPLY_IBL_SPECULAR == 1
	IBL4.rgb *= LightAmbient.rgb + 0.5;
	#endif
	#endif
	
	float3 IBL_B		= pow( max(0,dot( (LightDirection * float3 (1.0,-1.0,1.0)), Normal )), 1 );
	IBL1.rgb *= IBL_B.rgb;
	
	Color.rgb = lerp(Color.rgb, Color.rgb * IBL.rgb, 0.25 * IBL_Intensity);
	ShadowColor.rgb = lerp(ShadowColor.rgb, ShadowColor.rgb + IBL1,IBL_Intensity);
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 0
	#if APPLY_SPECULAR == 1
	Specular.rgb = lerp(Specular.rgb, Specular.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	#endif
	
	#if APPLY_IBL_SPECULAR == 1
	#if APPLY_ANISO == 1
	Aniso.rgb = lerp(Aniso.rgb, Aniso.rgb * IBL4.rgb,IBL_Intensity);
	#endif
	#endif
	
	#endif
	}
	//////////////////////////////////////////////////
	}
//////////////////////////////////////////////////
//SubSurfaceToon

	if(SSS_Valid)
	{ } else {
 	#if APPLY_SUBSURFACETOON == 1
	
	float3 SubSurfaceToon = min(pow(dot(Normal, -LightDirection), SubSurfaceToon_Size), ShadowComp) * SubSurfaceToon_Color.rgb * 1 * SubSurfaceToon_Bright;
	
    float3 SubSurfaceToon1 = pow( max(0,dot( EyeL, Normal)), 2) * SubSurfaceToon_Color * float(0.3) * SubSurfaceToon_Bright;
	
	float3 SubSurfaceToon2 = saturate(pow( 1 - dot(Normal * float3(1,1,-1), EyeL), 1 ) * SubSurfaceToon_Color) * SubSurfaceToon_Bright * float(0.3);

	float3 SubSurfaceToonDisplay = saturate(pow(1.0 - dot( LightDirection, Eye ), 2));
	float3 SubSurfaceToonDisplay1 = saturate(pow(1.0 - dot( -LightDirection, Eye ), 2));
	
	SubSurfaceToon *= SubSurfaceToonDisplay;
	SubSurfaceToon1 *= SubSurfaceToonDisplay;
	SubSurfaceToon2 *= SubSurfaceToonDisplay1;
	
	float3 SubSurfaceToonM = lerp(SubSurfaceToon1.rgb, SubSurfaceToon1.rgb + SubSurfaceToon2.rgb, 1);
	
	#if APPLY_SUBSURFACETOON_MAP == 1
	float4 SubSurfaceToonMap = tex2D(SubSurfaceToon_Map_Sampler, UV);
	SubSurfaceToonc.rgb *= SubSurfaceToonMap.rgb;
	SubSurfaceToonM.rgb *= SubSurfaceToonMap.rgb;
	
	SubSurfaceToonc.rgb *= SubSurfaceToonMap.a;
	SubSurfaceToonM.rgb *= SubSurfaceToonMap.a;
	#endif
	
	SubSurfaceToon *= LightAmbient + 0.5;
	
	ShadowColor.rgb += SubSurfaceToon;
	ShadowColor.rgb += SubSurfaceToonM;
	#endif
	}

//////////////////////////////////////////////////

	#if SHADER_TYPE == 1
	float3 HalfLambert = min(pow(dot(Normal, -LightDirection) * 0.5 + 0.5, 2) * 0.5 + 0.5, (1,1,ShadowComp));
	HalfLambert = pow(HalfLambert * 0.5 + 0.5, 1.0) * (HalfLambert.rgb = pow(HalfLambert, ShadowColor * HalfLambert * 0.5 + 0.5));
	
	ShadowComp = HalfLambert;
	#endif

//////////////////////////////////////////////////
//Shadow Color
	
	#if APPLY_TINT == 0
	#if APPLY_BACK_LIGHT == 1
	ShadowColor.rgb =  lerp(ShadowColor.rgb,1,Back_Light.rgb);
	#endif
	#if APPLY_FRONT_LIGHT == 1
	ShadowColor.rgb = lerp(ShadowColor.rgb,1,Front_Light.rgb);
	#endif
	
	#if SHADOW_AFFECT_SPECULAR_REFLECTIONS == 1
	Color.rgb = lerp(Color.rgb,1,Ref * lerp(1,ShadowComp, Reflection_Shadow_Effect_Intensity));
	#endif
	
	#endif
	
	#if APPLY_TINT == 1
	#if APPLY_BACK_LIGHT == 1
	ShadowColor.rgb += Back_Light;
	#endif
	#if APPLY_FRONT_LIGHT == 1
	ShadowColor.rgb += Front_Light * ShadowComp;
	#endif
	
	#if SHADOW_AFFECT_SPECULAR_REFLECTIONS == 1
	Color.rgb += Ref * lerp(1,ShadowComp, Reflection_Shadow_Effect_Intensity);
	#endif
	
	#endif
	
	if(SSS_Valid)
	{
		float2 texCoord = float2( ( IN.PPos.x/IN.PPos.w + 1.0f ) * 0.5f, 1.0f - ( IN.PPos.y/IN.PPos.w + 1.0f ) * 0.5f ) + 2;
		float4 SSSM = tex2Dlod(SSS_Samp, float4(texCoord.xy, 0, 1));
		
		#if APPLY_SUBSURFACETOON == 0
		#if APPLY_SUBSURFACETOON_FILTER_SHADOW == 1
		float SSSTC = (SSSM.r+SSSM.g+SSSM.b)/3;
		float4 SSSC = float4(SSSTC,SSSTC,SSSTC,SSSM.a);
		
		SSSM = lerp(SSSC, SSSM, SSSM.a * 0.0);
		
		Color.rgb = lerp(Color.rgb, Color.rgb * SSSM.rgb,SubSurfaceToon_Intensity);
		ShadowColor.rgb = lerp(ShadowColor.rgb, ShadowColor.rgb * SSSM.rgb, 0.5 * SubSurfaceToon_Intensity);
		#endif
		#endif
		
		#if APPLY_SUBSURFACETOON == 1
		float SSSTC = (SSSM.r+SSSM.g+SSSM.b)/3;
		float4 SSSC = float4(SSSTC,SSSTC,SSSTC,SSSM.a);
		
		SSSM = lerp(SSSC, SSSM, SSSM.a * SubSurfaceToon_Saturation);
		
		Color.rgb = lerp(Color.rgb, Color.rgb * SSSM.rgb,SubSurfaceToon_Intensity);
		ShadowColor.rgb = lerp(ShadowColor.rgb, ShadowColor.rgb * SSSM.rgb, 1.0);
		#endif
	}
	
	ShadowColor *= Toon_Intensity;
	
	Color.rgb  = lerp(Color.rgb * ShadowColor.rgb, Color.rgb, ShadowComp);
	
//////////////////////////////////////////////////
	
	#if APPLY_TONE_MAP == 1
	Color.rgb += Brightness_Plus;
	Color.rgb -= Brightness_Less;
	Transparency = 1 + -Transparency;
	float3 scene_tone		= ColorToneMapping(Color.rgb);
	Color.rgb				= lerp(Color.rgb,scene_tone,Tone_Map_Intensity * Transparency);
	#endif

//////////////////////////////////////////////////
        return Color;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////
// Techniques
technique PGTech  < string MMDPass = "object_ss"; > {
    pass DrawObject {
		#if BLEND_APPLY == 1
		
		#if SRC_BLEND_TYPE == 0
		SRCBLEND = ZERO;
		#endif
		#if SRC_BLEND_TYPE == 1
		SRCBLEND = ONE;
		#endif
		#if SRC_BLEND_TYPE == 2
		SRCBLEND = SrcColor;
		#endif
		#if SRC_BLEND_TYPE == 3
		SRCBLEND = INVSrcColor;
		#endif
		#if SRC_BLEND_TYPE == 4
		SRCBLEND = SrcAlpha;
		#endif
		#if SRC_BLEND_TYPE == 5
		SRCBLEND = INVSrcAlpha;
		#endif
		#if SRC_BLEND_TYPE == 6
		SRCBLEND = DestAlpha;
		#endif
		#if SRC_BLEND_TYPE == 7
		SRCBLEND = INVDestAlpha;
		#endif
		#if SRC_BLEND_TYPE == 8
		SRCBLEND = DestColor;
		#endif
		#if SRC_BLEND_TYPE == 9
		SRCBLEND = INVDestColor;
		#endif

		#if DEST_BLEND_TYPE == 0
		DESTBLEND = ZERO;
		#endif
		#if DEST_BLEND_TYPE == 1
		DESTBLEND = ONE;
		#endif
		#if DEST_BLEND_TYPE == 2
		DESTBLEND = SrcColor;
		#endif
		#if DEST_BLEND_TYPE == 3
		DESTBLEND = INVSrcColor;
		#endif
		#if DEST_BLEND_TYPE == 4
		DESTBLEND = SrcAlpha;
		#endif
		#if DEST_BLEND_TYPE == 5
		DESTBLEND = INVSrcAlpha;
		#endif
		#if DEST_BLEND_TYPE == 6
		DESTBLEND = DestAlpha;
		#endif
		#if DEST_BLEND_TYPE == 7
		DESTBLEND = INVDestAlpha;
		#endif
		#if DEST_BLEND_TYPE == 8
		DESTBLEND = DestColor;
		#endif
		#if DEST_BLEND_TYPE == 9
		DESTBLEND = INVDestColor;
		#endif
		
		#endif

		#if ALPHA_BLEND_APPLY == 1
		
		#if ALPHA_BLEND_TYPE == 1
		ALPHABLENDENABLE = FALSE;
		#endif
		
		#if ALPHA_BLEND_TYPE == 2
		ALPHABLENDENABLE = TRUE;
		#endif
		
		#endif
		
		#if ALPHA_TEST_APPLY == 1
		
		#if ALPHA_TEST_TYPE == 1
		ALPHATESTENABLE = FALSE;
		#endif

		#if ALPHA_TEST_TYPE == 2
		ALPHATESTENABLE = TRUE;
		#endif

		#endif
		
		#if Z_WRITE_APPLY == 1
		
		#if Z_WRITE_TYPE == 1
		ZWRITEENABLE = FALSE;
		#endif
		
		#if Z_WRITE_TYPE == 2
		ZWRITEENABLE = TRUE;
		#endif
		
		#endif
		
		#if Z_ENABLE_APPLY == 1
		
		#if Z_TYPE == 1
		ZENABLE = FALSE;
		#endif
		
		#if Z_TYPE == 2
		ZENABLE = TRUE;
		#endif
		
		#endif
		
		#if CULLMODE_APPLY == 1
		
		#if CULLMODE_TYPE == 0
		CULLMODE = NONE;
		#endif
		
		#if CULLMODE_TYPE == 1
		CULLMODE = CW;
		#endif
		
		#if CULLMODE_TYPE == 2
		CULLMODE = CCW;
		#endif
		
		#endif
        VertexShader = compile vs_3_0 BufferShadow_VS();
        PixelShader  = compile ps_3_0 BufferShadow_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
